import { Route, Routes } from "react-router-dom";
import Login from "./pages/auth/Login";
import ProtectedRoute from "./routes/ProtectedRoute";
import LoginGuard from "./routes/LoginGuard";
import Home from "./pages/home/Home";
import Register from "./pages/auth/Register";
import Layout from "./components/layout";
import CourseDetails from "./pages/course/Course";
import Lesson from "./pages/lesson/Lesson";

function App() {
  const data =
    '# Build a Recursive Depth-First Search (DFS) for Graphs\n\n> **Module:** Tackling Complex Data Structures with Recursion â€¢ **Level:** Intermediate â€¢ **Time:** 30 minutes\n\n## ðŸŽ¯ Lesson Goals\n*By the end of this lesson, you\'ll be able to:*\n- **Build** a fully functional recursive DFS algorithm for graph traversal.\n- **Debug** common errors in DFS implementations, such as infinite loops due to unvisited nodes.\n- **Explain** the time and space complexity implications of recursive DFS.\n- **Apply** DFS to solve connectivity problems in graphs.\n\n## ðŸ“– Story & Context\nImagine you\'re building a social network. Users are connected by friendships, forming a vast graph. You need to find all the friends of a specific user, and their friends, and so on â€“ essentially exploring the network reachable from that user.  DFS provides a powerful and elegant solution to this problem.  Without DFS (and similar graph traversal algorithms) , our social networks wouldn\'t be able to recommend new connections, search for specific individuals, or display personalized feeds.\n\n**Real-World Impact:**\n*   **Social Networks:** Finding connected users, suggesting friends.\n*   **Web Crawlers:** Navigating the web by following links from one page to another.\n*   **Route Finding:**  Finding a path between two points in a network (e.g., GPS navigation).\n\n## ðŸ§  Core Concepts Explained\n### The Fundamental Idea\nDFS is like exploring a maze. You pick a path, follow it until you hit a dead end, then backtrack and try another path. In graphs, "paths" are sequences of connected nodes, and "dead ends" are nodes with no unvisited neighbors. The key is to mark visited nodes to avoid infinite loops.\n\n### How It Works Under the Hood\n1.  **Start at a node:**  This is your initial exploration point.\n2.  **Mark it as visited:**  This prevents revisiting and infinite loops.\n3.  **Explore its neighbors:**  For each unvisited neighbor, recursively call DFS on that neighbor.\n4.  **Backtrack (implicitly):** When a node has no unvisited neighbors, the recursive call returns, effectively backtracking to the previous node.  The call stack manages this beautifully.\n\n### Key Components & Their Roles\n- **Visited Set:**  A data structure (e.g., a boolean array or a set) that keeps track of visited nodes.  Purpose: Prevent infinite loops and ensure each node is explored only once.\n- **Recursive Function:** The core of the algorithm. Purpose: Explores the graph layer by layer. How it interacts: Calls itself on unvisited neighbors, managing the traversal.  Why it\'s essential: Provides the elegant, depth-first exploration logic.\n- **Adjacency List (or Matrix):**  The representation of the graph.  Purpose: Stores the connections between nodes.  How it interacts: The DFS algorithm uses the adjacency list to find the neighbors of a given node. Why it\'s essential: Provides the structure for the traversal.\n\n## ðŸ’» Code in Action\n\n### Example 1: Basic Implementation\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>>& adj, vector<bool>& visited) {\n  // 1. Mark the current node as visited\n  visited[node] = true;\n  cout << "Visiting node: " << node << endl;\n\n  // 2. Iterate through the neighbors of the current node\n  for (int neighbor : adj[node]) {\n    // 3. If the neighbor hasn\'t been visited, recursively call DFS on it\n    if (!visited[neighbor]) {\n      dfs(neighbor, adj, visited);\n    }\n  }\n  // Implicit Backtracking: When all neighbors are visited, the function returns\n}\n\nint main() {\n  int numNodes = 6;\n  vector<vector<int>> adj(numNodes); // Adjacency list representation\n\n  // Add edges to the graph (example graph)\n  adj[0].push_back(1);\n  adj[0].push_back(2);\n  adj[1].push_back(2);\n  adj[2].push_back(0);\n  adj[2].push_back(3);\n  adj[3].push_back(3); // Self-loop\n  adj[4].push_back(5);\n\n  vector<bool> visited(numNodes, false); // Initialize all nodes as unvisited\n\n  // Start DFS from node 0\n  cout << "Starting DFS from node 0:" << endl;\n  dfs(0, adj, visited);\n\n  // If the graph is disconnected, you might want to start DFS from other unvisited nodes\n    for (int i = 0; i < numNodes; ++i) {\n        if (!visited[i]) {\n            cout << "Starting DFS from node " << i << ":" << endl;\n            dfs(i, adj, visited);\n        }\n    }\n\n  return 0;\n}\n```\n\n**What this demonstrates:** This example demonstrates the core recursive DFS algorithm: marking visited nodes, exploring neighbors, and the implicit backtracking mechanism.  It also illustrates how to handle disconnected graphs by iterating through unvisited nodes after the initial DFS.\n\n### Example 2: Real-World Scenario - Connected Components\n\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>>& adj, vector<bool>& visited, vector<int>& component) {\n  visited[node] = true;\n  component.push_back(node); // Add the node to the current component\n\n  for (int neighbor : adj[node]) {\n    if (!visited[neighbor]) {\n      dfs(neighbor, adj, visited, component);\n    }\n  }\n}\n\nint main() {\n  int numNodes = 8;\n  vector<vector<int>> adj(numNodes);\n\n  // Example graph representing a network with multiple connected components\n  adj[0].push_back(1);\n  adj[1].push_back(0);\n  adj[2].push_back(3);\n  adj[3].push_back(2);\n  adj[4].push_back(5);\n  adj[5].push_back(4);\n  adj[6].push_back(7);\n  adj[7].push_back(6);\n\n  vector<bool> visited(numNodes, false);\n  vector<vector<int>> connectedComponents;\n\n  for (int i = 0; i < numNodes; ++i) {\n    if (!visited[i]) {\n      vector<int> component;\n      dfs(i, adj, visited, component); // Find a connected component\n      connectedComponents.push_back(component);\n    }\n  }\n\n  cout << "Connected Components:" << endl;\n  for (const auto& component : connectedComponents) {\n    cout << "[";\n    for (int node : component) {\n      cout << node << " ";\n    }\n    cout << "]" << endl;\n  }\n\n  return 0;\n}\n```\n\n**When you\'d use this:** Use this pattern to identify distinct groups of connected elements within a network. This is useful in network analysis, identifying clusters of users, or determining the number of isolated networks.\n\n## ðŸ› ï¸ Hands-On Workshop\n\n### Exercise: Build a Path Finding Function\n\n**Scenario:** You have a graph representing a map of cities and roads.  You want to determine if a path exists between two given cities.\n\n**Your Task:** Implement a function `pathExists(graph, start, end)` that uses DFS to determine if a path exists from the `start` node to the `end` node in the given `graph`.  The `graph` is represented as an adjacency list.  Return `true` if a path exists, and `false` otherwise.\n\n**Success Looks Like:** The function should correctly identify if a path exists between any two nodes in a given graph. It should handle disconnected graphs and cases where the start or end node is invalid.\n\n**Starter Code:**\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool pathExists(vector<vector<int>>& adj, int start, int end, vector<bool>& visited) {\n  // Base case: If the start and end nodes are the same, a path exists\n    if (start == end) {\n        return true;\n    }\n\n    visited[start] = true; // Mark as visited\n\n    // Iterate through neighbors\n    for (int neighbor : adj[start]) {\n        // If the neighbor hasn\'t been visited\n        if (!visited[neighbor]) {\n            // Recursively check for a path from the neighbor to the end\n            if (pathExists(adj, neighbor, end, visited)) {\n                return true; // Path found!\n            }\n        }\n    }\n\n    // No path found from the current node to the end\n    return false;\n}\n\n\nbool pathExists(vector<vector<int>>& adj, int start, int end) {\n    int numNodes = adj.size();\n    vector<bool> visited(numNodes, false); // Keep track of visited nodes\n\n    //Error checking\n    if (start < 0 || start >= numNodes || end < 0 || end >= numNodes){\n        return false;\n    }\n    return pathExists(adj, start, end, visited); // Kick off the recursive DFS\n}\n\n\nint main() {\n  int numNodes = 6;\n  vector<vector<int>> adj(numNodes);\n\n  // Add edges to the graph\n  adj[0].push_back(1);\n  adj[0].push_back(2);\n  adj[1].push_back(2);\n  adj[2].push_back(0);\n  adj[2].push_back(3);\n  adj[3].push_back(3);\n  adj[4].push_back(5);\n\n  // Test cases\n  cout << "Path from 0 to 3: " << pathExists(adj, 0, 3) << endl; // true\n  cout << "Path from 0 to 4: " << pathExists(adj, 0, 4) << endl; // false\n  cout << "Path from 4 to 5: " << pathExists(adj, 4, 5) << endl; // true\n  cout << "Path from 5 to 4: " << pathExists(adj, 5, 4) << endl; // false\n  cout << "Path from 1 to 3: " << pathExists(adj, 1, 3) << endl; // true\n\n  return 0;\n}\n```\n\n### Pro Tips for Success\nðŸ”¥ **Accelerate Your Learning:**\n- **Visualize:**  Draw the graph and trace the DFS algorithm step-by-step to better understand the recursion.  Understanding the call stack is crucial.\n- **Simplify:**  Start with small, simple graphs and gradually increase the complexity.\n- **Experiment:**  Modify the code, add more nodes and edges, and observe the behavior of the algorithm.\n\nâš ï¸ **Common Pitfalls & Solutions:**\n- **Missing Base Case:** Leads to infinite recursion and stack overflow. â†’ Ensure you have a base case that stops the recursion (e.g., reaching the end node or having no unvisited neighbors).\n- **Forgetting to Mark as Visited:** Causes infinite loops. â†’ Always mark a node as visited before exploring its neighbors.\n- **Stack Overflow:**  With very deep graphs, recursive DFS can lead to stack overflow.  â†’ Consider using iterative DFS with an explicit stack (covered in later lessons).\n\n## ðŸŒ Real-World Applications\n\n| Industry | Use Case | Why It Matters |\n|----------|----------|----------------|\n| **Telecommunications** | Network Routing | Optimizing data transfer paths across a network to minimize latency and congestion. |\n| **Transportation** | GPS Navigation | Finding the shortest or fastest route between two locations, considering traffic conditions and road closures. |\n| **Bioinformatics** |  Protein Interaction Networks |  Identifying relationships between proteins and predicting protein function.  |\n| **Your Project** |  Dependency Resolution in a Build System | Efficiently managing and resolving dependencies between software modules to ensure a successful build. |\n\n## ðŸ§ª Knowledge Check\n\n### Quick Quiz\n**Q1: Scenario-Based Application**\n"You are building a system to detect cycles in a directed graph representing task dependencies. Which approach would be most effective and why?"\nA) Breadth-First Search (BFS) - Explores layer by layer.\nB) Depth-First Search (DFS) - Explores deeply before backtracking.\nC) Dijkstra\'s Algorithm - Finds the shortest path.\nD) Prim\'s Algorithm - Finds the minimum spanning tree.\n\n**Q2: Code Analysis**\n"What\'s the primary limitation of this implementation of recursive DFS in very large, deeply nested graphs, and how would you improve it?"\n[Brief code snippet: the basic DFS function from Example 1]\n\n**Q3: Decision Making**\n"When would you choose recursive DFS over iterative DFS, and what factors would influence your decision?"\n\n<details>\n<summary>ðŸ“‹ Answers & Explanations</summary>\n\n**Q1: B**  \n*Why:* DFS is naturally suited for cycle detection. During DFS, if you encounter a node that is already in the current path (the recursion stack), you\'ve found a cycle. BFS doesn\'t maintain this path information as easily. Dijkstra\'s and Prim\'s algorithms are for different types of problems.\n\n**Q2:** Stack overflow. The depth of recursion can exceed the stack size for large graphs.  â†’ Use iterative DFS with an explicit stack.\n\n**Q3:**  Recursive DFS is simpler to implement and read for smaller to medium-sized graphs where stack overflow isn\'t a concern. Iterative DFS is necessary for larger graphs to avoid stack overflow but is more complex to implement. Factors include graph size, stack size limitations, and code readability preferences.\n</details>\n\n## ðŸš€ Putting It All Together\n\n### Key Takeaways\n- ðŸŽ¯ **Core Insight:** DFS systematically explores a graph by going as deep as possible along each branch before backtracking.\n- ðŸ”§ **Practical Skill:**  You can now build a recursive DFS algorithm and adapt it to solve various graph problems.\n- âš¡ **Performance Tip:**  Be mindful of stack overflow potential in very large graphs and consider iterative DFS.\n- ðŸŽ¨ **Architectural Pattern:**  DFS is well-suited for problems involving path finding, connectivity analysis, and cycle detection.\n\n### Your Learning Journey\n**From this lesson:** You can now implement and apply recursive DFS to solve graph traversal problems.  \n**To next lesson:** **Debug Stack Overflow Errors in Recursive Code** - Learn how to identify and fix stack overflow errors in recursive functions by optimizing base cases and recursion depth.\n\n### Ready for More?\n- **Challenge exercise:** Implement cycle detection using DFS in a directed graph.\n- **Recommended reading:** CLRS (Introduction to Algorithms) - Chapter on Graph Algorithms\n- **Community project idea:** Build a visualizer that shows the DFS traversal of a graph in real-time.\n\n---\n\n*Lesson designed for I know DSA fundamentals and solved nearly 30standard questions to build practical Mastering Recursion and Backtracking for Algorithmic Problem Solving skills.*\n';

  return (
    <div className="bg-gray-900 dark">
      <Routes>
        <Route element={<ProtectedRoute />}>
          <Route element={<Layout />}>
            <Route path="/" element={<Home />} />
            <Route path="/course/:id" element={<CourseDetails />} />
            <Route
              path="/course/:courseId/module/:modNum/lesson/:lessonNum"
              element={<Lesson content={data} />}
            />
          </Route>
        </Route>
        <Route
          path="/login"
          element={
            <LoginGuard>
              <Login />
            </LoginGuard>
          }
        />
        <Route
          path="/register"
          element={
            <LoginGuard>
              <Register />
            </LoginGuard>
          }
        />
      </Routes>
    </div>
  );
}

export default App;
