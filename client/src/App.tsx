import { Route, Routes } from "react-router-dom";
import Login from "./pages/auth/Login";
import ProtectedRoute from "./routes/ProtectedRoute";
import LoginGuard from "./routes/LoginGuard";
import Home from "./pages/home/Home";
import Register from "./pages/auth/Register";
import Layout from "./components/layout";
import CourseDetails from "./pages/course/Course";
import Lesson from "./pages/lesson/Lesson";

function App() {
  const data = "# Solve a Challenging DP Problem from Codeforces\n\n## üîç Why This Lesson Matters\n\nThis lesson is crucial because it bridges the gap between understanding DP concepts and applying them to complex, real-world problems encountered in competitive programming. Codeforces problems are known for their intricate constraints and require a deep understanding of DP combined with problem-solving skills. Mastering these types of problems will significantly improve your ability to identify DP opportunities in seemingly unrelated scenarios, optimize solutions for performance, and ultimately excel in competitive programming contests. Learning to dissect and conquer these challenges translates to a more robust and adaptable problem-solving skillset applicable far beyond the realm of coding competitions.\n\n## üß† Core Concepts\n\nLet's break down the key aspects we need to tackle complex Codeforces DP problems:\n\n1.  **Problem Decomposition:** The art of dissecting a seemingly intractable problem into smaller, overlapping subproblems. Think of it like splitting a giant pizza into manageable slices. Each slice is a subproblem, and solving each slice incrementally leads to solving the entire pizza problem.\n\n2.  **State Definition:** Identifying the essential parameters that define a subproblem. Imagine each subproblem is a unique state in a system. This state has to be defined using variables, and accurately defining your state is the bedrock of a DP solution. For example, `dp[i][j]` could represent the solution to a subproblem considering the first `i` items with a maximum weight capacity of `j`.\n\n3.  **Base Cases:** Defining the simplest subproblems whose solutions are known without further computation. These are your anchor points, the initial conditions that allow your DP algorithm to build upon. Like the foundation of a house, your base cases must be rock solid.  A common base case is `dp[0][0] = 0`, meaning with no items and no capacity, the solution is 0.\n\n4.  **Recursive Relation (Transition):** Expressing the solution to a subproblem in terms of the solutions to smaller subproblems. This is where the \"dynamic\" in dynamic programming comes to life.  The transition is the recipe for combining smaller solutions into a larger one. A typical transition might be: `dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])`, meaning you either don't include the current item or you do.\n\n5.  **Memoization/Tabulation:**  Storing the solutions to subproblems to avoid redundant computations. This is the core of DP's efficiency. Memoization is top-down (recursive with caching), while tabulation is bottom-up (iterative). Think of it like writing down the answers to math problems in a notebook to avoid solving them again. Tabulation is like filling out a spreadsheet from left to right, top to bottom.\n\n**Visual Mental Model:** Imagine a directed acyclic graph (DAG). Each node represents a subproblem (a state), and the edges represent the transitions (recursive relations). You're essentially traversing this DAG, computing the value of each node based on the values of its predecessors, until you reach the final node representing the overall solution.\n\n## üíª Practical Examples\n\nLet's tackle a Codeforces problem to illustrate these concepts:\n\n**Problem:** (Simplified version of Codeforces Problem 706B - Interesting Drink)\n\nYou are given an array `prices` of `n` drinks and `q` queries. Each query consists of an integer `money`. For each query, you need to find the number of drinks you can buy with the given amount of `money`.\n\n**Input:**\n\n```\nn = 3\nprices = [1, 2, 3]\nq = 2\nqueries = [2, 4]\n```\n\n**Output:**\n\n```\n2\n3\n```\n\n**Solution using Binary Search (Although DP isn't strictly required here, it illustrates the concept of optimized computation):**\n\n```python\ndef solve():\n  n = int(input())\n  prices = list(map(int, input().split()))\n  prices.sort() # Crucial for binary search\n  q = int(input())\n  for _ in range(q):\n    money = int(input())\n    \n    # Binary Search to find the largest index i such that prices[i] <= money\n    l, r = 0, n - 1\n    ans = -1\n    while l <= r:\n      mid = (l + r) // 2\n      if prices[mid] <= money:\n        ans = mid\n        l = mid + 1\n      else:\n        r = mid - 1\n\n    if ans == -1:\n      print(0)\n    else:\n      print(ans + 1)\n\n\nsolve()\n```\n\n**Explanation:**\n\n1.  **Problem Decomposition:** We are given `q` independent queries.  Each query is a subproblem: \"How many drinks can I buy with `money`?\".\n\n2.  **State Definition:** While DP isn't the core of this solution, the essential parameter is `money` for each query.  `prices` is a global parameter.  We sort prices because it allows us to efficiently find the answer with binary search.\n\n3.  **Base Cases:** The binary search implicitly handles the base cases (e.g., when `money` is less than the smallest price).\n\n4.  **Recursive Relation (Transition):** The binary search effectively represents a series of transitions, narrowing down the search space until it finds the index of the highest affordable drink. The `ans` value is iteratively refined based on comparing `prices[mid]` with `money`.\n\n5.  **Memoization/Tabulation:** Although this solution uses binary search, you could conceptually think of memoization. You could precompute the answers for a certain range of `money` values and store them in a table. However, binary search offers a sufficiently efficient solution without explicit memoization in this case.\n\n**Why this is related to DP:**\n\nThe core idea is that by sorting the `prices` array, we have essentially created an *ordered* state space that allows for optimized searching. This aligns with the core of DP, where we aim to solve overlapping subproblems in an optimal order.\n\n## üõ† Mini Exercise\n\n**Problem:** (Slightly modified version of the previous problem)\n\nYou are given an array `prices` of `n` drinks. You can buy each drink at most once. You are also given `q` queries. Each query consists of an integer `money`. For each query, you need to find the *maximum* number of *distinct* drinks you can buy with the given amount of `money`.\n\n**Hint:** This requires combining sorting with a more explicit \"knapsack\" style DP approach, but with the constraint of maximizing the *count* of items (drinks) rather than their total value. Think about how to structure your `dp` array to track the maximum number of drinks you can buy up to a certain price.\n\n## ‚ö†Ô∏è Common Mistakes\n\n1.  **Incorrect State Definition:**  Failing to identify the *minimum* set of parameters needed to define a subproblem. This often leads to incorrect or inefficient DP solutions. *Always* think about what information you *absolutely need* to solve a specific subproblem.\n\n2.  **Overlapping Subproblems Not Identified:** Mistaking a problem for one that *doesn't* benefit from DP. DP is only effective when subproblems truly overlap. If subproblems are entirely independent, a divide-and-conquer or greedy approach might be more suitable.\n\n3.  **Incorrect Transition Logic:** Defining the recursive relation incorrectly. This is often the trickiest part. *Carefully* consider how the solution to a subproblem depends on the solutions to smaller subproblems. Draw diagrams, work through small examples, and rigorously test your transition logic.\n\n4.  **Not Considering Base Cases:**  Forgetting to define the base cases or defining them incorrectly. This will lead to incorrect results and often infinite recursion (in memoization). *Always* start by identifying the simplest subproblems whose solutions are known.\n\n5.  **Time Limit Exceeded (TLE):**  Inefficient implementation of the DP algorithm.  Ensure your algorithm has the correct time complexity. Consider using tabulation instead of memoization if it offers better performance.  Optimize your code for speed (e.g., avoid unnecessary computations, use efficient data structures).\n\n## üöÄ Summary\n\nIn this lesson, we dove into solving challenging DP problems from Codeforces. We reviewed key concepts like problem decomposition, state definition, base cases, recursive relations, and memoization/tabulation. We tackled a Codeforces-style problem using binary search (illustrating the importance of optimized computation, a key aspect of DP thinking), and provided a mini-exercise to further solidify your understanding. We also highlighted common mistakes to avoid when implementing DP solutions.\n\n## üîó Next Step (Module Staircase)\n\nUp next: **Solve a Challenging DP Problem from AtCoder** ‚Äî Analyze and solve a complex DP problem from a competitive programming platform. This is the natural next step because AtCoder problems often require a slightly different flavor of DP techniques compared to Codeforces, focusing on precise mathematical formulations and clever state representations. Solving an AtCoder problem will broaden your DP skillset and expose you to a wider range of problem-solving strategies.\n"
  return (
    <div className="bg-gray-900 dark">
      <Routes>
        <Route element={<ProtectedRoute />}>
          <Route element={<Layout />}>
            <Route path="/" element={<Home />} />
            <Route path="/course/:id" element={<CourseDetails />} />
            <Route
              path="/course/:courseId/module/:modId/lesson/:lessonId"
              element={<Lesson />}
            />
          </Route>
        </Route>
        <Route
          path="/login"
          element={
            <LoginGuard>
              <Login />
            </LoginGuard>
          }
        />
        <Route
          path="/register"
          element={
            <LoginGuard>
              <Register />
            </LoginGuard>
          }
        />
      </Routes>
    </div>
  );
}

export default App;
